### 3. 테이블

!. SQL Server 2008부터 테이블 압축 기능이 제공된다. 대용량의 데이터가 들어간 테이블의 저장 공간을 대폭 절약할 수 있다. -> 2권에서 다룸



**테이블은 만드는 방법이 중요한 것이 아니라, 테이블을 어떻게 모델링(설계)했느냐가 훨씬 중요하다.**

**테이블을 만드는 것**은 설계에 따른 **SQL 문법이나 SSMS의 사용법에만 맞춰서 생성**하면 되는 것이다.



------------------------

#### IDENTITY

* 입력 실수 또는 삭제 후 다시 입력할 경우에 **identity 값이 설정된 num 열**은 처음으로 돌아가지 않고 **계속 증가된 값으로 입력**된다. 그럴 경우에 **identity 값을 변경**하려면 **'DBCC CHECKIDENT('테이블이름, RESEED, 초기값')'** 명령을 입력한다.

* identity가 설정된 열에 **강제로 값을 입력**하고 싶다면, **'SET IDENTITY_INSERT 테이블이름 ON'**으로 설정한 후에 입력하면 된다. 하지만 이것이 **실제로 사용되는 경우는 드물다**. 또, 이 SET 명령은 현재의 세션에서만 해당되는 것이며 **세션이 종료되면(=쿼리 창이 닫히면) 설정된 내용은 무효**가 된다.

---------------------

#### 제약조건

* 제약조건이란 데이터의 무결성을 지키려고 제한된 조건을 의미한다.

* 특정 데이터를 입력할 때 무조건적으로 입력되는 것이 아닌, **어떠한 조건을 만족했을 때에만 입력되게 제약**할 수 있다.
  * 예를들면 회원가입을 할 때 같은 주민등록번호로 가입하면 회원가입이 안된다. 그 이유는 주민등록번호 컬럼은 같은 것이 들어갈 수 없는 제약조건이 설정되어 있기 때문.



##### 6가지 제약조건

1. PRIMARY KEY

* 테이블에 많은 행의 데이터를 구분할 수 있는 **식별자**를 기본키라고 한다. 기본키에 입력되는 값은 **중복될 수 없으며, NULL 값이 입력될 수 없다. **

* 기본키로 생성한 것은 **자동으로 클러스터형 인덱스가 생성**된다. 또한, 테이블에서는 기본키를 **하나 이상의 열에 설정**할 수 있다. (두개 이상의 열을 합쳐 기본키로 설정할 수도 있다.) 물론 **기본키 없이도 테이블 구성이 가능**하다.

* 모든 제약조건은 이름을 가지게 되는데, CREATE TABLE 안에서 기본키를 지정하게 되면 제약 조건이름은 SQL Server가 알아서 설정해준다.



2. FOREIGN KEY

* 두 테이블 사이의 **관계를 선**언함으로써, 데이터의 무결성을 보장해주는 역할을 한다. 외래키 관계를 설정하게 되면 **하나의 테이블이 다른 테이블에 의존**하게 된다. 외래키를 정의하는 테이블과 참조하는 테이블을 가끔 혼동하는 경우가 있다. 
  * 외래키 테이블(외래키를 정의하는 테이블)이 참조하는 기준 테이블(외래키에 의해 참조되는 테이블)은의 열은 반드시 primary key이거나, Unique 제약 조건이 설정되어 있어야 한다. 

* 외래키 옵션
  * ON DELETE CASCADE / ON UPDATE CASCADE
  * 기준 테이블의 데이터가 변경되었을 때 외래키 테이블도 자동으로 적용하도록 설정.



3. UNIQUE

* **중복되지 않는 유일한 값**을 입력해야 하는 조건이다. 
* 기본키와 비슷하지만 NULL을 허용한다는 차이점이 있다. **NULL도 한 개만 허용**한다. 



4. CHECK

* 입력되는 데이터를 점검하는 기능을 한다. 키에 마이너스 값이 들어 올 수 없게 한다든지 등의 조건을 지정.

* CHECK (조건)



5. DEFAULT

* 값을 입력하지 않았을 때, 자동으로 입력되는 기본 값을 정의하는 방법이다. 

* DEFAULT(기본값)



6. Null 값 허용


---------

#### 스파스 열 (Sparse Column)

* SQL Server 2008부터 제공된다.

* Null 값에 대해 최적화된 저장소가 있는 일반 열로 정의할 수 있다.
  * 즉, **Null 값이 많이 들어갈 것으로 예상되는 열이라면 스파스 열로 지정**해 놓을 경우 많은 **공간 절약 효과**를 볼 수 있다. 그러나 **Null 값이 별로 없는 열이라면 그 크기가 더 필요**해진다. 
  * 즉, 스파스 열로 지정된 열에 Null 값을 입력하면 지정된 데이터 크기보다 적게 공간을 차지하지만 실제값이 입력되면 오히려 공간을 더 차지하게 된다.

* 열 뒤에 SPARSE만 붙이면 된다.
* 스파스 열은 몇가지 제약사항이 있다.
  * geometry, geography, image, text, ntext, timestamp, UDT에는 설정할 수 없다.
  * **반드시 NULL을 허용**해야 하며, **IDENTITY 속성을 허용할 수 없다.**
  * FILESTREAM 특성을 포함할 수 없다.
  * DEFAULT 값을 지정할 수 없다.
  * 스파스 열을 사용하면 행의 최대 크기가 8060바이트에서 8018바이트로 줄어든다.



-----------

#### 임시테이블

* 임시로 잠깐 사용되는 테이블. 

* 테이블을 생성할 때 이름 앞에 #, ##를 붙이면 임시 테이블로 생성된다. 

* **tempdb에 생성**될 뿐, 나머지 사용법을 일반 테이블과 같다.

* `#` : 로컬 임시 테이블, 테이블을 생성한 사람만 사용할 수 있다. 다른 사용자는 해당 테이블이 있는지 조차 모른다

* `##` : 전역 임시 테이블. 모든 사용자가 사용할 수 있는 테이블이다.

* 임시테이블 삭제는 사용자가 직접 삭제하거나 **SQL Server가 재시작되면 삭제**된다. 또 생성자의 **연결이 끊어지면 삭제**





* 열의 추가
  * ALTER TABLE 테이블이름 ADD 열이름 데이터형식
  * 기본적으로 가장 뒤에 추가된다. 



* 열의 삭제
  * ALTER TABLE 테이블이름 DROP COLUMN 열이름



* 열의 데이터 형식 변경
  * ALTER TABLE 테이블이름 ALTER COLUMN 열이름 변경데이터형식



* 열 이름 변경
  * EXEC sp_rename '테이블.열', '변경하려는 이름', 'COLUMN'



* 열의 제약조건 추가 및 삭제
  * ALTER TABLE 테이블이름 DROP CONSTRAINT 열이름





----------

#### 스키마

* 데이터베이스 내에 있는 모든 개체(테이블, 뷰, 인덱스, 트리거, 프로시저 등)의 정식 명칭을 살펴보면 다음과 같은 형식을 갖는다.
  * `데이터베이스_이름.스키마_이름.개체_이름`

* 스키마는 데이터베이스 내에 있는 **개체들을 관리하는 묶음**이라고 생각하면 된다.

* **편하게 관리하려고 가볍게 테이블을 묶어준다고 생각하는 것이 좋다.** 테이블이 몇개 없다면 굳이 별도의 스키마에 테이블을 분류하지 않아도 괜찮다. 

* 디폴트 스키마는 dbo 이다.





------------

### 뷰

* 사용자 입장에서는 테이블과 같이 사용하는 개체이다. 

* 한 번 생성해 놓으면 테이블이라고 생각하고 사용해도 될 정도로 사용자들의 입장에서는 테이블과 거의 같은 개체로 여겨진다.



* 개념
  * SELECT 출력 결과가 결국 테이블 모양을 가진다 -> 조회 결과를 테이블로 봐도 무방하지 않을까?

```mssql
CREATE VIEW 뷰이름 

AS

	SELECT 구문

GO

```



* 장점
  * 보안에 도움이 된다.
  * 복잡한 쿼리를 단순화시켜 줄 수 있다. -> 자주 사용하는 쿼리를 뷰로 만들어 뷰에 접근만 하면 되도록



* 종류

  * 표준 뷰 : 한 개 또는 그 이상의 테이블을 이용해서 만든 뷰
  * 분할 뷰 : 한 대 또는 여러 대의 **서버에 있는 테이블을 조인**해서 **하나의 테이블처럼** 보이게 하는 뷰
    * 로컬 분할 뷰 : 여러 테이블이 **한 대의 SQL Server**에 있다. -> 분할된 테이블을 사용하는 것이 더 좋다.
    * 분산형 분할 뷰 : 여러 테이블이 **여러 대의 SQL Server**에 있다.
  * 인덱싱된 뷰 : **인덱스를 구성하려면 실제 데이터를 가지고 있어야 한다.** 하지만 뷰의 단점 중 하나는 **대량의 데이터를 조인**할 경우, 실시간으로 쿼리가 수행되어  **SQL Server에 큰 부하**를 준다는 점이다(이것은 테이블도 마찬가지). 그래서 부하를 줄이는 방편으로 **뷰에 실제 데이터**를 가져다 놓는다면 **뷰가 자주 사용될 경우**에 더 이상 대량의 데이터를 조인할 필요 없이 **직접 뷰에서 데이터를 가져오면 되므로, 큰 성능 향상**을 가져올 수 있다. 물론 이렇게 하면 단점도 생긴다. **표준 뷰**는 데이터를 가지고 있지 않아서 **공간을 차지하지 않지만,** 인덱싱된 뷰는 **별도의 공간이 필요**하다. 또한, **실제 테이블의 데이터가 수정**될 경우에 이 인덱싱된 **뷰의 데이터도 수정**되어야 하므로 데이터의 변경이 잦을 경우 시스템 성능에 나쁜 영향을 줄 수 있다. 따라서 인덱싱된 뷰는 조회는 자주 있지만, 수정은 가끔 있는 테이블에 구성하는 것이 바람직하다.

  * 시스템 뷰 : SQL Server는 상태 및 내부 정보를 관리하는 시스템 테이블이 있고, 사용자는 이 테이블에 직접 접근이 불가능하다. 그 대신 시스템 상태를 파악하기 위해 시스템 뷰를 제공해주고 있다.







